#!/usr/bin/env python
"""
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

    Based on a proof-of-concept written by Christian Gatzemeier (Copyright (c) 2007)  
    Copyright (c) 2017 Riley Baxter
"""

import argparse
import distutils.dir_util
import os
import shutil
import socket
import subprocess

def main():
    main_parser = argparse.ArgumentParser(description='Manages an installation medium for installing/updating packages on multiple (possibly disconnected and/or remote) systems.')
    sub_parsers = main_parser.add_subparsers(dest='action')
    
    main_parser.add_argument('-im', '--install-medium', type=str, default=os.getcwd(), help='path to installation medium (defaults to current working directory)')
    main_parser.add_argument('-m', '--install-medium', type=str, default=os.getcwd(), help='path to installation medium (defaults to current working directory)')
    
    # Create a parser for the init command
    init_parser = sub_parsers.add_parser('init', help='initialize or update the dpkg status and apt configuration for this system in the installation medium')
    
    # Create a parser for the install command
    install_parser = sub_parsers.add_parser('install', help='install or upgrade a package (or queue the action if downloads are needed)')
    
    # Create a parser for the download command
    download_parser = sub_parsers.add_parser('download', help='download files/packages needed to complete pending actions')
    
    args = main_parser.parse_args()
    
    if os.path.isdir(args.install_medium):
        os.chdir(args.install_medium)
    else:
        print('The specified installation medium (' + args.install_medium + ') does not exist.')
        exit(-1)
    
    if args.action == 'init':
        exitCode = init_action(args)
    elif args.action == 'install':
        exitCode = install_action(args)
    elif args.action == 'download':
        exitCode = download_action(args)
    
    exit(exitCode)

def sync_local_lists():
    medium_lists_dir = 'lists'
    local_lists_dir = '/var/lib/apt/lists'
    for file in os.listdir(local_lists_dir):
        src_file = os.path.join(local_lists_dir, file)
        dst_file = os.path.join(medium_lists_dir, file)
        
        if file == 'lock' or not os.path.isfile(src_file):
            continue
        
        if not os.path.exists(dst_file) or os.path.getmtime(src_file) > os.path.getmtime(dst_file):
            shutil.copy(src_file,dst_file)
    


def init_action(args):
    hostname = socket.gethostname()
    
    info_dir = 'system_info'
    system_dir = os.path.join(info_dir, hostname)
    system_etc_dir = os.path.join(system_dir, 'etc')
    
    lists_dir = 'lists'
    lists_partial_dir = os.path.join(lists_dir, 'partial')
    
    archives_dir = 'archives'
    archives_partial_dir = os.path.join(archives_dir, 'partial')
    
    # Create directory structure
    for directory in [info_dir, system_dir, system_etc_dir,
                      lists_dir, lists_partial_dir, archives_dir,
                      archives_partial_dir]:
        if not os.path.exists(directory):
            os.mkdir(directory)
    
    # Copy necessary information about the system
    system_apt_dir = os.path.join(system_etc_dir, 'apt')
    shutil.copy('/var/lib/dpkg/status', os.path.join(system_dir, 'dpkg-status'))
    if os.path.exists(system_apt_dir):
        shutil.rmtree(system_apt_dir)
    distutils.dir_util.copy_tree('/etc/apt', system_apt_dir)
    
    # Create an empty apt.conf.d folder if one doesn't exist
    apt_conf_d_dir = os.path.join(system_apt_dir, 'apt.conf.d')
    if not os.path.exists(apt_conf_d_dir):
        os.mkdir(apt_conf_d_dir)
    
    # Create an empty apt.conf file if one doesn't exist
    apt_conf = os.path.join(system_apt_dir, 'apt.conf')
    open(apt_conf, 'a').close()
    
    # Create a base configuration that loads apt.conf.d and apt.conf
    apt_medium_conf = os.path.join(system_apt_dir, 'apt-medium.conf')
    am_conf = open(apt_medium_conf, 'w')
    
    am_conf.write('APT\n')
    am_conf.write('    {\n')
    am_conf.write('    Architecture "' + subprocess.check_output(['dpkg', '--print-architecture']).splitlines()[0] + '";\n');
    foreign_archs = subprocess.check_output(['dpkg', '--print-foreign-architectures']).splitlines()
    if len(foreign_archs) > 0:
        am_conf.write('    Architectures {')
        for arch in foreign_archs:
            am_conf.write('"' + arch + '";')
        am_conf.write('};\n')
    # keep all lists (i.e. those not in current sources.list file) on apt-medium for use by offline machines
    am_conf.write('    Get::List-Cleanup "false";\n')
    am_conf.write('    };\n')
    
    am_conf.write('Dir\n')
    am_conf.write('    {\n')
    am_conf.write('    State "/' + system_dir + '";\n')
    am_conf.write('    State::status "dpkg-status";\n')
    am_conf.write('    State::Lists "/' + lists_dir + '";\n')
    am_conf.write('    Cache "/' + system_dir + '";\n')
    am_conf.write('    Cache::archives "/' + archives_dir + '";\n')
    am_conf.write('    Etc "/' + system_apt_dir + '";\n')
    am_conf.write('    };\n')
    
    am_conf.close()
    
    sync_local_lists()
    
    return 0

def install_action(args):
    raise NotImplementedError()

    # If we're about to install packages, check if we're running as root
    if os.geteuid() != 0:
        raise Exception('apt-medium must be run as root to install packages')

def download_action(args):
    raise NotImplementedError()

if __name__ == '__main__':
    main()
