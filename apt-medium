#!/bin/bash

#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#    (c) Christian Gatzemeier 2007

echo
echo "apt-medium itself is not a usable script yet!"
echo "In the meantime the apt-medium-* proof-of-concept helpers are your friends!:"
echo
echo "  apt-medium-init"
echo "               to initialise an apt-medium on your target machine"
echo
echo "  apt-medium-download <apt-tool> <apt-tool-options>"
echo "               to download everything on your download machine"
echo
echo "               Example: 0) apt-medium-download apt-get update"
echo "                        1) apt-medium-download apt-get upgrade"
echo
echo "  apt-medium-install"
echo "               to install what you downloaded on your target machine"
echo
echo
echo
echo -n "Do you want to see the some pseudo code for apt-medium? (y/n)"
read READ_INPUT
if [ "$READ_INPUT" = y ]; then
  cat $0 | more
fi
exit 0


SYNOPSIS
  apt-medium [--machine=MACHINE_NAME] [--apt-tool= { apt-get* | aptidude | synaptic | ... }] \
		{ update | online-update | download | any-apt-tool-command }


function sync_apt-medium (
	$MACHINE_NAME ='hostname'

	# allways override $MACHINE_NAME/etc/apt before installing packages
	# (untrustable keys and config on medium)
	
	#possibly check if files differ before writring files
	cp /var/lib/dpkg/status $APT_MEDIUM_DIR/machine/$MACHINE_NAME/$MACHINE_NAME-dpkg-status
	cp -r  /etc/apt  $APT_MEDIUM_DIR/$MACHINE_NAME/etc/
	mv $APT_MEDIUM_DIR/$MACHINE_NAME/etc/apt/apt.conf $APT_MEDIUM_DIR/$MACHINE_NAME/etc/apt/apt.conf-$MACHINE_NAME

	# check if apt-medium files on $APT_MEDIUM_DIR are unaltered and up to date
	diff /usr/bin/apt-medium $APT_MEDIUM_DIR/apt-medium
	diff /var/share/doc/apt-medium/apt-medium.bat $APT_MEDIUM_DIR/apt-medium.bat
	diff /var/share/doc/apt-medium/w32bin/* $APT_MEDIUM_DIR/w32bin/*
	# warn / update with newer version

	#TODO: cp newer lists from machine's /var/lib/apt to apt-medium or vice versa!
	
	#create apt-medium.conf
	#apt-medium.conf is overrideing Download-Only="yes", state-dir, List-Cleanup,
	#and cache-dir from install machine's config on the download machine:
cat > $APT_MEDIUM_DIR/$MACHINE_NAME/etc/apt/apt-medium.conf-$MACHINE_NAME << EOP


/* $MACHINE_NAME's apt-medium.conf  */
/* on a download machine we use only the install machine's config from the medium */

/* first include all the install machine settings */

#include $APT_MEDIUM_DIR/$MACHINE_NAME/etc/apt/apt.conf-$MACHINE_NAME;

# TODO asure caching of packages on the apt-medium as long as we don't keep a full
# repository with own pkg lists on the $APT-MEDIUM (with apt-move/dpkg-rescanpackages).
# Such a repository can be tracked (automatically) by machines using update-notifier,
# cron-apt etc.
# ( Dir::Cache::archives might be disabled or get deleted on those machines)

APT
   {
   /* FIXME: At the moment we just assume to download
      for i386 Architecture */

   Architecture "i386";

   Get::Download-Only "true";

   /* keep all lists, i.e. alse those not used in current
      sources.lists on apt-medium for use by offline machines*/

   Get::List-Cleanup "false";

   };


Dir
  {

  /* make sure those are not set to somthing else in included config
     they would be read after our overrides */

/*  Etc::Parts "";
  Etc::main ""; */

  /* Use the status file  on the apt-medium */

  State "$APT_MEDIUM_DIR/machine/$MACHINE_NAME/";
  State::status "$APT_MEDIUM_DIR/machine/$MACHINE_NAME/$MACHINE_NAME-dpkg-status";


  /* share all lists and the package cache on the apt-medium */

  State::Lists "$APT_MEDIUM_DIR/lists/";
  Cache "$APT_MEDIUM_DIR/machine/$MACHINE_NAME/";
  Cache::archives "$APT_MEDIUM_DIR/archives/";

  Etc "$APT_MEDIUM_DIR/machine/$MACHINE_NAME/etc/apt/";

  };

EOP

)



# Missing code: first extract given command line options (--machine=MACHINE_NAME, --ui=APT_TOOL
# and --help) and keep the remaining in $APT_COMMAND


# offer to create apt-medium
if $PWD does not contain machine, lists, and archives directory ; then
	echo "The current direcory does not seem to be an apt-medium directory do you want to create one?"
	read DO_CREATE
	if $PWD does not end with /apt-medium; then
	  mkdir apt-medium
	  cd apt-medium
	fi
	# better only  mkdir if they don't exist yet (check before):
	mkdir machine
	mkdir machine/$MACHINE_NAME
	mkdir lists
	mkdir lists/partial
	mkdir archives
	mkdir archives/partial

fi



if [ "$#" = 0 ] (no parameters specified); then
  $1="--help"
fi
# Display usage if --help is true



# APT_TOOL should default to apt-get, or aptitude as this is recomended now?
# And apt-medium saves the requested $APT_COMMANDs.

# i.e. with $APT_TOOL=apt-get and $APT_COMMAND="install <package names>"
# this will be executed in download-only or print-uris
# mode, depending if we are on the download or install machine, and saved.
# To be used later without the need to download anything for
# installation on the install machine or downloaded without
# installing anything on download machines.

# APT_TOOLs like dselect, aptitude, or synaptic may keep their own state
# in the Dir::State directory (set to point to the apt-medium). Those $APT_TOOLs are
# usually called without any (package selection) $APT_COMMANDs.
# When they catch multiple executions gracefully they
# can be used to manage the apt-medium very convenietly.


# Missing code: Check for $APT_TOOL, if unavailable default to wget mode
# if wget is unavailable defaut to print uri_dl_list
if $APT_TOOL is empty $APT_TOOL=aptitude
if 'which $APT_TOOL' is empty $APT_TOOL=aptitude # do fallback for something that is not installed
if 'which $APT_TOOL' is empty $APT_TOOL=apt-get # a debian box without aptitude?
if 'which $APT_TOOL' is empty $APT_TOOL=wget # no debian, no apt-get
if 'which $APT_TOOL' is empty echo "no wget download on availabe on this machine"

case $APT_COMMAND
   =online-update do
	sync_apt-medium
	
	export APT_CONFIG="/$APT_MEDIUM_DIR/$MACHINE_NAME/etc/apt/apt-medium.conf-$MACHINE_NAME"
	aptitude update
	sync_apt-medium


   =download do
	if $MACHINE_NAME = "" #(download for all machines)
	  $MACHINE_NAMES="'dir $APT_MEDIUM_DIR/machine'"
	else $MACHINE_NAMES="$MACHINE_NAME"

	for  $MACHINE_NAME in $MACHINE_NAMES do
	   #(prevent parsing of the download machine's own config)
	   # and asure download-only and caching on apt-medium:
	   export APT_CONFIG="$APT_MEDIUM_DIR/machine/$MACHINE_NAME/etc/apt/apt-medium.conf-$MACHINE_NAME"

	   if $APT_TOOL=wget do
	      $WGET_CMD --directory-prefix=$APT_MEDIUM_DIR/lists -c -x -i $APT_MEDIUM_DIR/machine/$MACHINE_lists_dl_uris
	      $WGET_CMD --directory-prefix=$APT_MEDIUM_DIR/archives -c -i $APT_MEDIUM_DIR/machine/$MACHINE_pkg_dl_uris
	   else
	      apt-get update
	      for $APT_COMMAND in $APT_MEDIUM_DIR/machine/$MACHINE_NAME/$MACHINE_NAME-command_list do
	         $APT_TOOL $APT_COMMAND
	   fi
	   rm $APT_MEDIUM_DIR/machine/$MACHINE_NAME-lists_dl_uris
	   rm $APT_MEDIUM_DIR/machine/$MACHINE_NAME-pkg_dl_uris
	done

else
   # sync on install machines (untrustable keys on medium)
   if $MACHINE_NAME = 'hostname' or "" then
      sync_apt-medium
   fi

   if $APT_COMMAND != update
      echo $APT_COMMAND >> $APT_MEDIUM_DIR/$MACHINE_NAME/$MACHINE_NAME-apt_command_list
   fi

   #check the apt-medium:
   export APT_CONFIG="$APT_MEDIUM_DIR/$MACHINE_NAME/etc/apt/apt-medium.conf-$MACHINE_NAME"
   apt-get check


   # determine missing uris:
   if $APT_COMMAND = update do
      $APT_TOOL -o dir::etc::status=/var/lib/dpkg/status -qq --print-uris update | cut -d\' -f 2 > $APT_MEDIUM_DIR/$MACHINE_NAME/$MACHINE_NAME-lists_dl_uris
      echo "You can use this medium with "apt-medium download" to fetch updated package lists on a better conected machine later, or use "apt-medium online-update" to fetch package lists now."
   else
      for $APT_COMMAND in command_list do
         $APT_TOOL -o dir::etc::status=/var/lib/dpkg/status -qq --print-uris $APT_COMMAND | cut -d\' -f 2 >> $APT_MEDIUM_DIR/$MACHINE_NAME/$MACHINE_NAME-pkg_dl_uris
	 if uri_dl_list is not empty do
	   echo "If the apt-medium is at your download location do an "apt-medium download" to download all missing packages."
	 fi
      done
   fi


   # install what is available on install machines
   if $MACHINE_NAME = 'hostname' or "" 
	if the addition to uri_list had zero legth and $APT_COMMAND is not empty do
	     $APT_TOOL -o dir::etc::status=/var/lib/dpkg/status $APT_COMMAND
	fi

	# do all requested commands if "apt-medium download" has worked the uri_dl_list
	if uri_dl_list is empty do 
	   for $APT_COMMAND in $APT_MEDIUM_DIR/$MACHINE_NAME/$MACHINE_NAME-apt_command_list do
	      $APT_TOOL -o dir::etc::status=/var/lib/dpkg/status $APT_COMMAND
	fi
   fi
fi











Further enhancements
----------------

md5sum checking:

save md5sum sums in dl_uris lists and check them after wget download if md5sum binary is availabe
(like apt-zip does it)




Centralized package management:

Let machines (i.e. update-notifier, cron-apt etc.) source the apt-medium in its sources.list.

With apt-move apt-medium can assemble a controlled package repository tree on the apt-medium.
The reduced package lists will serve those (offline) machines.
(With apt-medium the install machines will use lists on the medium anyway, but this way you can use them
 to control what gets installed. You can even automate the process. Using apt-move on/in apt-medium you can
 manage a bunch of machines centrally even if they are not networked. Carry your apt-medium with you or distrubute it.)

Here is how apt-medium can temporarily override the machines sources.list on install machines
if you maintain a repository with apt-move on the apt-medium

	#echo "deb file:$APT_MEDIUM_DIR archive/" > $APT_MEDIUM_DIR/machine/$MACHINE_NAME/etc/apt/sources.list
or use sources.list.d directory to override?




let apt-medium fetch available packages from /var/cache/apt on the machines
(possibly obsoletes some downloads)


[machine] download-from-own-sources
let apt-medium consider the sources.list from the download machine
(possibly knows about faster local mirrors)



Downloading all packages installed on a particular machine
# How to download all installed Packages:
#
# COLUMNS=200 dpkg -l | grep '^ii' | awk '{ print $2 }' > /tmp/pkglist
# cat /tmp/pkglist | xargs apt-get --download-only --reinstall -y install

(for full backup, generate, save and add a config-changes and home .deb
 package to the package list?)

