#!/usr/bin/env python
"""
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

    Based on a proof-of-concept written by Christian Gatzemeier (Copyright (c) 2007)  
    Copyright (c) 2017 Riley Baxter
"""

import argparse
import distutils.dir_util
import os
import shutil
import socket
import subprocess

def main():
    main_parser = argparse.ArgumentParser(description='Manages an installation medium for installing/updating packages on multiple (possibly disconnected and/or remote) systems.')
    sub_parsers = main_parser.add_subparsers(dest='action')
    
    main_parser.add_argument('-im', '--install-medium', type=str, default=os.getcwd(), help='path to installation medium (defaults to current working directory)')
    
    # Create a parser for the init command
    init_parser = sub_parsers.add_parser('init', help='initialize or update the dpkg status and apt configuration for this system in the installation medium')

    # Create a parser for the install command
    install_parser = sub_parsers.add_parser('install', help='install or upgrade a package (or queue the action if downloads are needed)')

    # Create a parser for the download command
    download_parser = sub_parsers.add_parser('download', help='download files/packages needed to complete pending actions')
    
    args = main_parser.parse_args()
    
    if os.path.isdir(args.install_medium):
        os.chdir(args.install_medium)
    else:
        print('The specified installation medium (' + args.install_medium + ') does not exist.')
	exit(-1)
    
    if args.action == 'init':
        init_action(args)
    elif args.action == 'install':
        install_action(args)
    elif args.action == 'download':
        download_action(args)

def init_action(args):
    hostname = socket.gethostname()
    
    INFO_DIR = 'system_info'
    SYSTEM_DIR = os.path.join(INFO_DIR, hostname)
    SYSTEM_ETC_DIR = os.path.join(SYSTEM_DIR, 'etc')

    LISTS_DIR = 'lists'
    LISTS_PARTIAL_DIR = os.path.join(LISTS_DIR, 'partial')

    ARCHIVES_DIR = 'archives'
    ARCHIVES_PARTIAL_DIR = os.path.join(ARCHIVES_DIR, 'partial')

    # Create directory structure
    for directory in [INFO_DIR, SYSTEM_DIR, SYSTEM_ETC_DIR,
                      LISTS_DIR, LISTS_PARTIAL_DIR, ARCHIVES_DIR,
                      ARCHIVES_PARTIAL_DIR]:
        if not os.path.exists(directory):
            os.mkdir(directory)
    
    # Copy necessary information about the system
    SYSTEM_APT_DIR = os.path.join(SYSTEM_ETC_DIR, 'apt')
    shutil.copy('/var/lib/dpkg/status', os.path.join(SYSTEM_DIR, 'dpkg-status'))
    distutils.dir_util.copy_tree('/etc/apt', SYSTEM_APT_DIR)
    
    # Create an empty apt.conf file if one doesn't exist
    APT_CONF = os.path.join(SYSTEM_APT_DIR, 'apt.conf')
    if not os.path.exists(APT_CONF):
        open(APT_CONF, 'a').close()
    
    # Create a config file for downloading data with apt
    APT_MEDIUM_CONF = os.path.join(SYSTEM_APT_DIR, 'apt-medium.conf')
    am_conf = open(APT_MEDIUM_CONF, 'w')
    am_conf.write('#include ./' + APT_MEDIUM_CONF + ';\n')
    
    am_conf.write('APT\n')
    am_conf.write('    {\n')
    for arch in subprocess.check_output(['dpkg', '--print-architecture']).split(): 
        am_conf.write('    Architectures "' + arch + '";\n')
    am_conf.write('    Get::Download-Only "true";\n')
    # keep all lists (i.e. those not in current sources.list file) on apt-medium for use by offline machines
    am_conf.write('    Get::List-Cleanup "false";\n')
    am_conf.write('    };\n')

    am_conf.write('Dir\n')
    am_conf.write('    {\n')
    am_conf.write('    State "./' + SYSTEM_DIR + '";\n')
    am_conf.write('    State::status "dpkg-status";\n')
    am_conf.write('    State::Lists "./' + LISTS_DIR + '";\n')
    am_conf.write('    Cache "./' + SYSTEM_DIR + '";\n')
    am_conf.write('    Cache::archives "./' + ARCHIVES_DIR + '";\n')
    am_conf.write('    Etc "./' + SYSTEM_APT_DIR + '";\n')
    am_conf.write('    };\n')
    
    am_conf.close()


def install_action(args):
    raise NotImplementedError()

    # If we're about to install packages, check if we're running as root
    if os.geteuid() != 0:
        raise Exception('apt-medium must be run as root to install packages')

def download_action(args):
    raise NotImplementedError()

if __name__ == '__main__':
    main()
