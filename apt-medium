#!/usr/bin/env python
"""
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

    Based on a proof-of-concept written by Christian Gatzemeier (Copyright (c) 2007)  
    Copyright (c) 2017 Riley Baxter
"""

from __future__ import print_function

import argparse
import distutils.dir_util
import distutils.spawn
import os
import re
import shutil
import socket
import subprocess

from utils import getch

try:
    import cPickle as pickle
except ImportError as _:
    import pickle

def main():
    main_parser = argparse.ArgumentParser(description='Manages an installation medium for installing/updating packages on multiple (possibly disconnected and/or remote) systems.')
    sub_parsers = main_parser.add_subparsers(dest='action')
    
    main_parser.add_argument('-m', '--install-medium', type=str, default=os.getcwd(), help='path to installation medium (defaults to current working directory)')
    
    # Create a parser for the init command
    init_parser = sub_parsers.add_parser('init', help='initialize or update the dpkg status and apt configuration for this system in the installation medium')
    
    # Create a parser for the install command
    install_parser = sub_parsers.add_parser('install', help='install or upgrade a package (or queue the action if downloads are needed)')
    install_parser.add_argument('-t', '--target', type=str, default=socket.gethostname(), help='the hostname of the target system to perform the install/upgrade on (defaults to the current system)')
    install_parser.add_argument('packages', type=str, nargs='*', help='package name(s) to be installed')
    
    # Create a parser for the download command
    download_parser = sub_parsers.add_parser('download', help='download files/packages needed to complete pending actions')
    
    # TODO: Create a parser for the show-queue command
    
    # TODO: Create a parser for the clear-queue command 
    
    args = main_parser.parse_args()
    
    # Check if we are running as root
    if os.geteuid() != 0:
        print('apt-medium must be run as root')
        exit(-1)
    
    if not distutils.spawn.find_executable('apt-get'):
        print('Cannot find apt-get in PATH.')
        exit(-1)
    
    if not distutils.spawn.find_executable('dpkg'):
        print('Cannot find dpkg in PATH.')
        exit(-1)
    
    if not distutils.spawn.find_executable('rsync'):
        print('Cannot find rsync in PATH')
        exit(-1)
    
    args.install_medium = os.path.abspath(args.install_medium)
    
    if os.path.isdir(args.install_medium):
        os.chdir(args.install_medium)
    else:
        print('The specified installation medium (' + args.install_medium + ') does not exist.')
        exit(-1)
    
    # Attempt to create a necessary symlink
    try:
        if not os.path.islink('usr'):
            os.symlink('/usr','usr')
    except Exception as _:
        print('Failed to create a necessary symlink to /usr on installation medium.')
        exit(-1)
    
    try:
        f = open('testfile','w')
        f.write('test')
        f.close()
        os.unlink('testfile')
    except Exception as _:
        print('The specified installation medium (' + args.install_medium + ') does not appear to be writeable, read-only install mediums are not currently supported')
        exit(-1)
    
    if args.action == 'init':
        exitCode = init_action(args)
    elif args.action == 'install':
        exitCode = install_action(args)
    elif args.action == 'download':
        exitCode = download_action(args)
    
    # Cleanup
    if os.path.exists('redir_conf'):
        os.unlink('redir_conf')
    
    exit(exitCode)

def sync_local_lists():
    medium_lists_dir = 'lists'
    local_lists_dir = '/var/lib/apt/lists'
    for file in os.listdir(local_lists_dir):
        src_file = os.path.join(local_lists_dir, file)
        dst_file = os.path.join(medium_lists_dir, file)
        
        if file == 'lock' or not os.path.isfile(src_file):
            continue
        
        if not os.path.exists(dst_file) or os.path.getmtime(src_file) > os.path.getmtime(dst_file):
            shutil.copy(src_file,dst_file)
    
def load_medium_state():
    state_file = open('medium_state', 'rb')
    state = pickle.load(state_file)
    state_file.close()
    return state

def save_medium_state(state):
    state_file = open('medium_state', 'wb')
    pickle.dump(state, state_file, protocol=2)
    state_file.close()

def init_action(args):
    hostname = socket.gethostname()
    
    info_dir = 'system_info'
    system_dir = os.path.join(info_dir, hostname)
    system_etc_dir = os.path.join(system_dir, 'etc')
    
    lists_dir = 'lists'
    lists_partial_dir = os.path.join(lists_dir, 'partial')
    
    archives_dir = 'archives'
    archives_partial_dir = os.path.join(archives_dir, 'partial')
    
    # Create directory structure
    for directory in [info_dir, system_dir, system_etc_dir,
                      lists_dir, lists_partial_dir, archives_dir,
                      archives_partial_dir]:
        if not os.path.exists(directory):
            os.mkdir(directory)
    
    if not os.path.exists('medium_state'):
        state = {}
        state['install_queue'] = {}
        state['download_queue'] = {}
        save_medium_state(state)
    
    # Copy necessary information about the system
    system_apt_dir = os.path.join(system_etc_dir, 'apt')
    shutil.copy('/var/lib/dpkg/status', os.path.join(system_dir, 'dpkg-status'))
    if os.path.exists(system_apt_dir):
        shutil.rmtree(system_apt_dir)
    distutils.dir_util.copy_tree('/etc/apt', system_apt_dir)
    
    # Create an empty apt.conf.d folder if one doesn't exist
    apt_conf_d_dir = os.path.join(system_apt_dir, 'apt.conf.d')
    if not os.path.exists(apt_conf_d_dir):
        os.mkdir(apt_conf_d_dir)
    
    # Create an empty apt.conf file if one doesn't exist
    apt_conf = os.path.join(system_apt_dir, 'apt.conf')
    open(apt_conf, 'a').close()
    
    # Create a base configuration that loads apt.conf.d and apt.conf
    apt_medium_conf = os.path.join(system_apt_dir, 'apt-medium.conf')
    am_conf = open(apt_medium_conf, 'w')
    
    am_conf.write('APT\n')
    am_conf.write('    {\n')
    am_conf.write('    Architecture "' + subprocess.check_output(['dpkg', '--print-architecture']).splitlines()[0] + '";\n');
    foreign_archs = subprocess.check_output(['dpkg', '--print-foreign-architectures']).splitlines()
    if len(foreign_archs) > 0:
        am_conf.write('    Architectures {')
        for arch in foreign_archs:
            am_conf.write('"' + arch + '";')
        am_conf.write('};\n')
    # keep all lists (i.e. those not in current sources.list file) on apt-medium for use by offline machines
    am_conf.write('    Get::List-Cleanup "false";\n')
    am_conf.write('    };\n')
    
    am_conf.write('Dir\n')
    am_conf.write('    {\n')
    am_conf.write('    State "/' + system_dir + '";\n')
    am_conf.write('    State::status "dpkg-status";\n')
    am_conf.write('    State::Lists "/' + lists_dir + '";\n')
    am_conf.write('    Cache "/' + system_dir + '";\n')
    am_conf.write('    Cache::archives "/' + archives_dir + '";\n')
    am_conf.write('    Etc "/' + system_apt_dir + '";\n')
    am_conf.write('    };\n')
    
    am_conf.close()
    
    sync_local_lists()
    
    state = load_medium_state()
    if hostname not in state['install_queue']:
        state['install_queue'][hostname] = []
        state['download_queue'][hostname] = []
    save_medium_state(state)
    
    return 0

def install_action(args):
    target = args.target
    install_medium = args.install_medium
    packages = args.packages
    local_is_target = target == socket.gethostname()
    
    target_info_dir = os.path.join(install_medium, 'system_info', target)
    target_apt_dir = os.path.join(target_info_dir, 'etc', 'apt')
    
    # Verify install target has been initialized
    if not os.path.exists(target_info_dir):
        print('Cannot find target (' + target + ') check the spelling is correct and that the target has been initialized on the medium')
        return -1
    
    # Prepare configuration file to redirect location of /etc/apt in apt-get
    redir_conf = open('redir_conf','w')
    redir_conf.write('Dir::Etc "' + target_apt_dir + '";')
    redir_conf.close()
    env = os.environ
    env['APT_CONFIG'] = os.path.join(install_medium, 'redir_conf')
    
    parms = ['apt-get']
    
    # Set RootDir to installation medium location
    parms.append('-o')
    parms.append('RootDir=' + install_medium)
    
    # Load target's apt-medium.conf file 
    parms.append('-c')
    parms.append(os.path.join(target_apt_dir, 'apt-medium.conf'))
    
    parms.append('install')
    if packages:
        parms.extend(packages)
    else:
        state = load_app_state()
        if len(state['install_queue'][target]) > 0:
            packages = state['install_queue'][target]
            parms.extend(packages)
        else:
            print('Nothing to install')
            return 0
    
    # Check if all needed downloads are present
    uris = None
    try:
        check_parms = list(parms)
        check_parms.append('--print-uris')
        check_parms.append('-qq')
        uris = subprocess.check_output(check_parms)
    except subprocess.CalledProcessError as _:
        print('apt-get failed while checking for needed packages')
        return -1
    
    missing_packages = uris.splitlines()
    missing_packages = map(str.split, missing_packages)
    
    # Remove any empty lines
    try:
        while True:
            missing_packages.remove([])
    except ValueError as _:
        pass
    
    total_size = 0
    for item in missing_packages:
        total_size += int(item[2])
    
    if len(missing_packages) > 0:
        print('Need to download ' + str(len(missing_packages)) + ' packages totaling ' + '{:,}'.format(total_size) + ' bytes')
        while True:
            print('Add to download queue? Yes (y), No(n), or Show Details (s):', end='')
            response = getch()
            print('')
            response = response.lower()
            if response == 'y' or response == 'n':
                break
            elif response == 's':
                try:
                    detail_parms = list(parms)
                    detail_parms.append('--simulate')
                    detail_output = subprocess.check_output(detail_parms).splitlines()
                    for line in detail_output:
                        print(line)
                        if re.search(r'[0-9]* newly installed', line):
                            break
                except subprocess.CalledProcessError as _:
                    print('apt-get failed while attempting to show details')
            else:
                print('Invalid selection.')
        if response == 'y':
            state = load_medium_state()
            for package in packages:
                if package not in state['download_queue'][target]:
                    state['download_queue'][target].append(package)
                    print('Queued ' + package + ' for download')
                else:
                    print(package + ' already queued for download')
            save_medium_state(state)
        else: # response == 'n'
            return 0
    else:
        print('Ready to install')
        raise NotImplementedError()

def download_action(args):
    raise NotImplementedError()

if __name__ == '__main__':
    main()
